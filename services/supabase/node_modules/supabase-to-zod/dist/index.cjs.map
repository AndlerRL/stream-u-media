{"version":3,"sources":["../src/index.ts","../src/supabase-to-zod.ts","../src/lib/get-import-path.ts","../src/lib/transform-types.ts","../src/lib/get-node-name.ts"],"sourcesContent":["import supabaseToZod from './supabase-to-zod';\n\nexport { transformTypes, TransformTypesOptions } from './lib';\nexport default supabaseToZod;\n","import { generate } from 'ts-to-zod';\n\nimport fs from 'node:fs/promises';\nimport { join } from 'node:path';\nimport prettier from 'prettier';\n\nimport { z } from 'zod';\nimport {\n  transformTypes,\n  getImportPath,\n  transformTypesOptionsSchema,\n} from './lib';\n\nconst simplifiedJSDocTagSchema = z.object({\n  name: z.string(),\n  value: z.string().optional(),\n});\n\nconst getSchemaNameSchema = z.function().args(z.string()).returns(z.string());\n\nconst nameFilterSchema = z.function().args(z.string()).returns(z.boolean());\n\nconst jSDocTagFilterSchema = z\n  .function()\n  .args(z.array(simplifiedJSDocTagSchema))\n  .returns(z.boolean());\n\nexport const supabaseToZodOptionsSchema = transformTypesOptionsSchema\n  .omit({ sourceText: true })\n  .extend({\n    input: z.string(),\n    output: z.string(),\n    skipValidation: z.boolean().optional(),\n    maxRun: z.number().optional(),\n    nameFilter: nameFilterSchema.optional(),\n    jsDocTagFilter: jSDocTagFilterSchema.optional(),\n    getSchemaName: getSchemaNameSchema.optional(),\n    keepComments: z.boolean().optional().default(false),\n    skipParseJSDoc: z.boolean().optional().default(false),\n  });\n\nexport type SupabaseToZodOptions = z.infer<typeof supabaseToZodOptionsSchema>;\n\nexport default async function supabaseToZod(opts: SupabaseToZodOptions) {\n  const inputPath = join(process.cwd(), opts.input);\n  const outputPath = join(process.cwd(), opts.output);\n\n  const sourceText = await fs.readFile(inputPath, 'utf-8');\n\n  const parsedTypes = transformTypes({ sourceText, ...opts });\n\n  const { getZodSchemasFile, errors } = generate({\n    sourceText: parsedTypes,\n    ...opts,\n  });\n\n  if (errors.length > 0) {\n    throw new Error(errors.join('\\n'));\n  }\n\n  const zodSchemasFile = getZodSchemasFile(\n    getImportPath(outputPath, inputPath)\n  );\n\n  const prettierConfig = await prettier.resolveConfig(process.cwd());\n\n  await fs.writeFile(\n    outputPath,\n    await prettier.format(zodSchemasFile, {\n      parser: 'babel-ts',\n      ...prettierConfig,\n    })\n  );\n}\n","import slash from 'slash';\nimport { parse, relative } from 'path';\n\n/**\n * Resolve the path of an import.\n *\n * @param from path of the current file\n * @param to path of the import file\n * @returns relative path without extension\n */\nexport function getImportPath(from: string, to: string) {\n  const relativePath = slash(relative(from, to).slice(1));\n  const { dir, name } = parse(relativePath);\n\n  return `${dir}/${name}`;\n}\n","import ts from 'typescript';\nimport { z } from 'zod';\nimport { getNodeName } from './get-node-name';\n\nconst enumFormatterSchema = z.function().args(z.string()).returns(z.string());\nconst compositeTypeFormatterSchema = z\n  .function()\n  .args(z.string())\n  .returns(z.string());\n\nconst functionFormatterSchema = z\n  .function()\n  .args(z.string(), z.string())\n  .returns(z.string());\n\nconst tableOrViewFormatterSchema = z\n  .function()\n  .args(z.string(), z.string())\n  .returns(z.string());\n\nexport const transformTypesOptionsSchema = z.object({\n  sourceText: z.string(),\n  schema: z.string().default('public'),\n  enumFormatter: enumFormatterSchema.default(() => (name: string) => name),\n  compositeTypeFormatter: compositeTypeFormatterSchema.default(\n    () => (name: string) => name\n  ),\n  functionFormatter: functionFormatterSchema.default(\n    () => (name: string, type: string) => `${name}${type}`\n  ),\n  tableOrViewFormatter: tableOrViewFormatterSchema.default(\n    () => (name: string, operation: string) => `${name}${operation}`\n  ),\n});\n\nexport type TransformTypesOptions = z.infer<typeof transformTypesOptionsSchema>;\n\nexport const transformTypes = z\n  .function()\n  .args(transformTypesOptionsSchema)\n  .returns(z.string())\n  .implement((opts) => {\n    const {\n      schema,\n      tableOrViewFormatter,\n      enumFormatter,\n      compositeTypeFormatter,\n      functionFormatter,\n    } = opts;\n    const sourceFile = ts.createSourceFile(\n      'index.ts',\n      opts.sourceText,\n      ts.ScriptTarget.Latest\n    );\n\n    const typeStrings: string[] = [];\n    const enumNames: { name: string; formattedName: string }[] = [];\n    const compositeTypeNames: { name: string; formattedName: string }[] = [];\n\n    sourceFile.forEachChild((n) => {\n      const processDatabase = (n: ts.Node | ts.TypeNode) => {\n        if (ts.isPropertySignature(n)) {\n          // Schema\n          const schemaName = getNodeName(n);\n          if (schemaName === schema) {\n            n.forEachChild((n) => {\n              if (ts.isTypeLiteralNode(n)) {\n                n.forEachChild((n) => {\n                  if (ts.isPropertySignature(n) && ts.isIdentifier(n.name)) {\n                    if (['Tables', 'Views'].includes(n.name.text)) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            if (ts.isPropertySignature(n)) {\n                              // Table or View\n                              const tableOrViewName = getNodeName(n);\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  n.forEachChild((n) => {\n                                    if (ts.isPropertySignature(n)) {\n                                      const operation = getNodeName(n);\n                                      if (operation) {\n                                        n.forEachChild((n) => {\n                                          if (\n                                            ts.isTypeLiteralNode(n) ||\n                                            // Handle `Relationships` operation which is an array\n                                            ts.isTupleTypeNode(n)\n                                          ) {\n                                            typeStrings.push(\n                                              `export type ${tableOrViewFormatter(\n                                                tableOrViewName,\n                                                operation,\n                                              )} = ${n.getText(sourceFile)}`,\n                                            );\n                                          }\n                                        });\n                                      }\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('Enums' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            const enumName = getNodeName(n);\n                            if (ts.isPropertySignature(n)) {\n                              n.forEachChild((n) => {\n                                if (ts.isUnionTypeNode(n)) {\n                                  const formattedName = enumFormatter(enumName);\n                                  typeStrings.push(\n                                    `export type ${formattedName} = ${n.getText(\n                                      sourceFile,\n                                    )}`,\n                                  );\n                                  enumNames.push({\n                                    formattedName,\n                                    name: enumName,\n                                  });\n                                }\n\n                                // Handle single-member enums\n                                if (ts.isLiteralTypeNode(n)) {\n                                  const formattedName = enumFormatter(enumName);\n                                  typeStrings.push(\n                                    `export type ${formattedName} = ${n.getText(\n                                      sourceFile,\n                                    )}`,\n                                  );\n                                  enumNames.push({\n                                    formattedName,\n                                    name: enumName,\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('CompositeTypes' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            const enumName = getNodeName(n);\n                            if (ts.isPropertySignature(n)) {\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  const formattedName =\n                                    compositeTypeFormatter(enumName);\n                                  typeStrings.push(\n                                    `export type ${formattedName} = ${n.getText(\n                                      sourceFile,\n                                    )}`,\n                                  );\n                                  compositeTypeNames.push({\n                                    formattedName,\n                                    name: enumName,\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                    if ('Functions' === n.name.text) {\n                      n.forEachChild((n) => {\n                        if (ts.isTypeLiteralNode(n)) {\n                          n.forEachChild((n) => {\n                            if (ts.isPropertySignature(n)) {\n                              const functionName = getNodeName(n);\n                              n.forEachChild((n) => {\n                                if (ts.isTypeLiteralNode(n)) {\n                                  n.forEachChild((n) => {\n                                    if (ts.isPropertySignature(n)) {\n                                      const argType = getNodeName(n);\n                                      n.forEachChild((n) => {\n                                        if (ts.isTypeReferenceNode(n)) {\n                                          typeStrings.push(\n                                            `export type ${functionFormatter(\n                                              functionName,\n                                              argType,\n                                            )} = ${n.getText(sourceFile)}`,\n                                          );\n                                        }\n                                      });\n                                    }\n                                  });\n                                }\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }\n                });\n              }\n            });\n          }\n        }\n      };\n\n      // Database\n      if (\n        ts.isTypeAliasDeclaration(n) &&\n        ts.isTypeLiteralNode(n.type) &&\n        n.name.text === 'Database'\n      ) {\n        n.type.members.forEach(processDatabase);\n      } else if (ts.isInterfaceDeclaration(n) && n.name.text === 'Database') {\n        n.forEachChild(processDatabase);\n      }\n\n      if (ts.isTypeAliasDeclaration(n) && n.name.text === 'Json') {\n        typeStrings.push(n.getText(sourceFile));\n      }\n    });\n\n    let parsedTypes = typeStrings\n      .filter((s) => !s.includes('Record<number'))\n      .join(';\\n');\n\n    for (const { name, formattedName } of enumNames) {\n      parsedTypes = parsedTypes.replaceAll(\n        `Database[\"${schema}\"][\"Enums\"][\"${name}\"]`,\n        formattedName\n      );\n      parsedTypes = parsedTypes.replaceAll(\n        `Database['${schema}']['Enums']['${name}']`,\n        formattedName\n      );\n    }\n\n    for (const { name, formattedName } of compositeTypeNames) {\n      parsedTypes = parsedTypes.replaceAll(\n        `Database[\"${schema}\"][\"CompositeTypes\"][\"${name}\"]`,\n        formattedName,\n      );\n      parsedTypes = parsedTypes.replaceAll(\n        `Database['${schema}']['CompositeTypes']['${name}']`,\n        formattedName,\n      );\n    }\n\n    return parsedTypes;\n  });\n","import ts from 'typescript';\n\nexport const getNodeName = (n: ts.Node) => {\n  let name: string | undefined;\n  n.forEachChild((n) => {\n    if (ts.isIdentifier(n)) {\n      name = n.text;\n    }\n\n    // Handle quoted identifiers in case they contain special characters\n    if (ts.isStringLiteral(n)) {\n      name = n.text;\n    }\n  });\n  if (!name) throw new Error('Cannot get name of node');\n  return name;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,uBAAyB;AAEzB,sBAAe;AACf,uBAAqB;AACrB,sBAAqB;AAErB,IAAAA,cAAkB;;;ACNlB,mBAAkB;AAClB,kBAAgC;AASzB,SAAS,cAAc,MAAc,IAAY;AACtD,QAAM,mBAAe,aAAAC,aAAM,sBAAS,MAAM,EAAE,EAAE,MAAM,CAAC,CAAC;AACtD,QAAM,EAAE,KAAK,KAAK,QAAI,mBAAM,YAAY;AAExC,SAAO,GAAG,GAAG,IAAI,IAAI;AACvB;;;ACfA,IAAAC,qBAAe;AACf,iBAAkB;;;ACDlB,wBAAe;AAER,IAAM,cAAc,CAAC,MAAe;AACzC,MAAI;AACJ,IAAE,aAAa,CAACC,OAAM;AACpB,QAAI,kBAAAC,QAAG,aAAaD,EAAC,GAAG;AACtB,aAAOA,GAAE;AAAA,IACX;AAGA,QAAI,kBAAAC,QAAG,gBAAgBD,EAAC,GAAG;AACzB,aAAOA,GAAE;AAAA,IACX;AAAA,EACF,CAAC;AACD,MAAI,CAAC;AAAM,UAAM,IAAI,MAAM,yBAAyB;AACpD,SAAO;AACT;;;ADZA,IAAM,sBAAsB,aAAE,SAAS,EAAE,KAAK,aAAE,OAAO,CAAC,EAAE,QAAQ,aAAE,OAAO,CAAC;AAC5E,IAAM,+BAA+B,aAClC,SAAS,EACT,KAAK,aAAE,OAAO,CAAC,EACf,QAAQ,aAAE,OAAO,CAAC;AAErB,IAAM,0BAA0B,aAC7B,SAAS,EACT,KAAK,aAAE,OAAO,GAAG,aAAE,OAAO,CAAC,EAC3B,QAAQ,aAAE,OAAO,CAAC;AAErB,IAAM,6BAA6B,aAChC,SAAS,EACT,KAAK,aAAE,OAAO,GAAG,aAAE,OAAO,CAAC,EAC3B,QAAQ,aAAE,OAAO,CAAC;AAEd,IAAM,8BAA8B,aAAE,OAAO;AAAA,EAClD,YAAY,aAAE,OAAO;AAAA,EACrB,QAAQ,aAAE,OAAO,EAAE,QAAQ,QAAQ;AAAA,EACnC,eAAe,oBAAoB,QAAQ,MAAM,CAAC,SAAiB,IAAI;AAAA,EACvE,wBAAwB,6BAA6B;AAAA,IACnD,MAAM,CAAC,SAAiB;AAAA,EAC1B;AAAA,EACA,mBAAmB,wBAAwB;AAAA,IACzC,MAAM,CAAC,MAAc,SAAiB,GAAG,IAAI,GAAG,IAAI;AAAA,EACtD;AAAA,EACA,sBAAsB,2BAA2B;AAAA,IAC/C,MAAM,CAAC,MAAc,cAAsB,GAAG,IAAI,GAAG,SAAS;AAAA,EAChE;AACF,CAAC;AAIM,IAAM,iBAAiB,aAC3B,SAAS,EACT,KAAK,2BAA2B,EAChC,QAAQ,aAAE,OAAO,CAAC,EAClB,UAAU,CAAC,SAAS;AACnB,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,aAAa,mBAAAE,QAAG;AAAA,IACpB;AAAA,IACA,KAAK;AAAA,IACL,mBAAAA,QAAG,aAAa;AAAA,EAClB;AAEA,QAAM,cAAwB,CAAC;AAC/B,QAAM,YAAuD,CAAC;AAC9D,QAAM,qBAAgE,CAAC;AAEvE,aAAW,aAAa,CAAC,MAAM;AAC7B,UAAM,kBAAkB,CAACC,OAA6B;AACpD,UAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAE7B,cAAM,aAAa,YAAYA,EAAC;AAChC,YAAI,eAAe,QAAQ;AACzB,UAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,gBAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,cAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,oBAAI,mBAAAD,QAAG,oBAAoBC,EAAC,KAAK,mBAAAD,QAAG,aAAaC,GAAE,IAAI,GAAG;AACxD,sBAAI,CAAC,UAAU,OAAO,EAAE,SAASA,GAAE,KAAK,IAAI,GAAG;AAC7C,oBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,0BAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,wBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,8BAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAE7B,kCAAM,kBAAkB,YAAYA,EAAC;AACrC,4BAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,kCAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,gCAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,sCAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAC7B,0CAAM,YAAY,YAAYA,EAAC;AAC/B,wCAAI,WAAW;AACb,sCAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,4CACE,mBAAAD,QAAG,kBAAkBC,EAAC;AAAA,wCAEtB,mBAAAD,QAAG,gBAAgBC,EAAC,GACpB;AACA,sDAAY;AAAA,4CACV,eAAe;AAAA,8CACb;AAAA,8CACA;AAAA,4CACF,CAAC,MAAMA,GAAE,QAAQ,UAAU,CAAC;AAAA,0CAC9B;AAAA,wCACF;AAAA,sCACF,CAAC;AAAA,oCACH;AAAA,kCACF;AAAA,gCACF,CAAC;AAAA,8BACH;AAAA,4BACF,CAAC;AAAA,0BACH;AAAA,wBACF,CAAC;AAAA,sBACH;AAAA,oBACF,CAAC;AAAA,kBACH;AACA,sBAAI,YAAYA,GAAE,KAAK,MAAM;AAC3B,oBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,0BAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,wBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,gCAAM,WAAW,YAAYA,EAAC;AAC9B,8BAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAC7B,4BAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,kCAAI,mBAAAD,QAAG,gBAAgBC,EAAC,GAAG;AACzB,sCAAM,gBAAgB,cAAc,QAAQ;AAC5C,4CAAY;AAAA,kCACV,eAAe,aAAa,MAAMA,GAAE;AAAA,oCAClC;AAAA,kCACF,CAAC;AAAA,gCACH;AACA,0CAAU,KAAK;AAAA,kCACb;AAAA,kCACA,MAAM;AAAA,gCACR,CAAC;AAAA,8BACH;AAGA,kCAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,sCAAM,gBAAgB,cAAc,QAAQ;AAC5C,4CAAY;AAAA,kCACV,eAAe,aAAa,MAAMA,GAAE;AAAA,oCAClC;AAAA,kCACF,CAAC;AAAA,gCACH;AACA,0CAAU,KAAK;AAAA,kCACb;AAAA,kCACA,MAAM;AAAA,gCACR,CAAC;AAAA,8BACH;AAAA,4BACF,CAAC;AAAA,0BACH;AAAA,wBACF,CAAC;AAAA,sBACH;AAAA,oBACF,CAAC;AAAA,kBACH;AACA,sBAAI,qBAAqBA,GAAE,KAAK,MAAM;AACpC,oBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,0BAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,wBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,gCAAM,WAAW,YAAYA,EAAC;AAC9B,8BAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAC7B,4BAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,kCAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,sCAAM,gBACJ,uBAAuB,QAAQ;AACjC,4CAAY;AAAA,kCACV,eAAe,aAAa,MAAMA,GAAE;AAAA,oCAClC;AAAA,kCACF,CAAC;AAAA,gCACH;AACA,mDAAmB,KAAK;AAAA,kCACtB;AAAA,kCACA,MAAM;AAAA,gCACR,CAAC;AAAA,8BACH;AAAA,4BACF,CAAC;AAAA,0BACH;AAAA,wBACF,CAAC;AAAA,sBACH;AAAA,oBACF,CAAC;AAAA,kBACH;AACA,sBAAI,gBAAgBA,GAAE,KAAK,MAAM;AAC/B,oBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,0BAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,wBAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,8BAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAC7B,kCAAM,eAAe,YAAYA,EAAC;AAClC,4BAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,kCAAI,mBAAAD,QAAG,kBAAkBC,EAAC,GAAG;AAC3B,gCAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,sCAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAC7B,0CAAM,UAAU,YAAYA,EAAC;AAC7B,oCAAAA,GAAE,aAAa,CAACA,OAAM;AACpB,0CAAI,mBAAAD,QAAG,oBAAoBC,EAAC,GAAG;AAC7B,oDAAY;AAAA,0CACV,eAAe;AAAA,4CACb;AAAA,4CACA;AAAA,0CACF,CAAC,MAAMA,GAAE,QAAQ,UAAU,CAAC;AAAA,wCAC9B;AAAA,sCACF;AAAA,oCACF,CAAC;AAAA,kCACH;AAAA,gCACF,CAAC;AAAA,8BACH;AAAA,4BACF,CAAC;AAAA,0BACH;AAAA,wBACF,CAAC;AAAA,sBACH;AAAA,oBACF,CAAC;AAAA,kBACH;AAAA,gBACF;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAGA,QACE,mBAAAD,QAAG,uBAAuB,CAAC,KAC3B,mBAAAA,QAAG,kBAAkB,EAAE,IAAI,KAC3B,EAAE,KAAK,SAAS,YAChB;AACA,QAAE,KAAK,QAAQ,QAAQ,eAAe;AAAA,IACxC,WAAW,mBAAAA,QAAG,uBAAuB,CAAC,KAAK,EAAE,KAAK,SAAS,YAAY;AACrE,QAAE,aAAa,eAAe;AAAA,IAChC;AAEA,QAAI,mBAAAA,QAAG,uBAAuB,CAAC,KAAK,EAAE,KAAK,SAAS,QAAQ;AAC1D,kBAAY,KAAK,EAAE,QAAQ,UAAU,CAAC;AAAA,IACxC;AAAA,EACF,CAAC;AAED,MAAI,cAAc,YACf,OAAO,CAAC,MAAM,CAAC,EAAE,SAAS,eAAe,CAAC,EAC1C,KAAK,KAAK;AAEb,aAAW,EAAE,MAAM,cAAc,KAAK,WAAW;AAC/C,kBAAc,YAAY;AAAA,MACxB,aAAa,MAAM,gBAAgB,IAAI;AAAA,MACvC;AAAA,IACF;AACA,kBAAc,YAAY;AAAA,MACxB,aAAa,MAAM,gBAAgB,IAAI;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AAEA,aAAW,EAAE,MAAM,cAAc,KAAK,oBAAoB;AACxD,kBAAc,YAAY;AAAA,MACxB,aAAa,MAAM,yBAAyB,IAAI;AAAA,MAChD;AAAA,IACF;AACA,kBAAc,YAAY;AAAA,MACxB,aAAa,MAAM,yBAAyB,IAAI;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT,CAAC;;;AF/OH,IAAM,2BAA2B,cAAE,OAAO;AAAA,EACxC,MAAM,cAAE,OAAO;AAAA,EACf,OAAO,cAAE,OAAO,EAAE,SAAS;AAC7B,CAAC;AAED,IAAM,sBAAsB,cAAE,SAAS,EAAE,KAAK,cAAE,OAAO,CAAC,EAAE,QAAQ,cAAE,OAAO,CAAC;AAE5E,IAAM,mBAAmB,cAAE,SAAS,EAAE,KAAK,cAAE,OAAO,CAAC,EAAE,QAAQ,cAAE,QAAQ,CAAC;AAE1E,IAAM,uBAAuB,cAC1B,SAAS,EACT,KAAK,cAAE,MAAM,wBAAwB,CAAC,EACtC,QAAQ,cAAE,QAAQ,CAAC;AAEf,IAAM,6BAA6B,4BACvC,KAAK,EAAE,YAAY,KAAK,CAAC,EACzB,OAAO;AAAA,EACN,OAAO,cAAE,OAAO;AAAA,EAChB,QAAQ,cAAE,OAAO;AAAA,EACjB,gBAAgB,cAAE,QAAQ,EAAE,SAAS;AAAA,EACrC,QAAQ,cAAE,OAAO,EAAE,SAAS;AAAA,EAC5B,YAAY,iBAAiB,SAAS;AAAA,EACtC,gBAAgB,qBAAqB,SAAS;AAAA,EAC9C,eAAe,oBAAoB,SAAS;AAAA,EAC5C,cAAc,cAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,KAAK;AAAA,EAClD,gBAAgB,cAAE,QAAQ,EAAE,SAAS,EAAE,QAAQ,KAAK;AACtD,CAAC;AAIH,eAAO,cAAqC,MAA4B;AACtE,QAAM,gBAAY,uBAAK,QAAQ,IAAI,GAAG,KAAK,KAAK;AAChD,QAAM,iBAAa,uBAAK,QAAQ,IAAI,GAAG,KAAK,MAAM;AAElD,QAAM,aAAa,MAAM,gBAAAE,QAAG,SAAS,WAAW,OAAO;AAEvD,QAAM,cAAc,eAAe,EAAE,YAAY,GAAG,KAAK,CAAC;AAE1D,QAAM,EAAE,mBAAmB,OAAO,QAAI,2BAAS;AAAA,IAC7C,YAAY;AAAA,IACZ,GAAG;AAAA,EACL,CAAC;AAED,MAAI,OAAO,SAAS,GAAG;AACrB,UAAM,IAAI,MAAM,OAAO,KAAK,IAAI,CAAC;AAAA,EACnC;AAEA,QAAM,iBAAiB;AAAA,IACrB,cAAc,YAAY,SAAS;AAAA,EACrC;AAEA,QAAM,iBAAiB,MAAM,gBAAAC,QAAS,cAAc,QAAQ,IAAI,CAAC;AAEjE,QAAM,gBAAAD,QAAG;AAAA,IACP;AAAA,IACA,MAAM,gBAAAC,QAAS,OAAO,gBAAgB;AAAA,MACpC,QAAQ;AAAA,MACR,GAAG;AAAA,IACL,CAAC;AAAA,EACH;AACF;;;ADtEA,IAAO,cAAQ;","names":["import_zod","slash","import_typescript","n","ts","ts","n","fs","prettier"]}